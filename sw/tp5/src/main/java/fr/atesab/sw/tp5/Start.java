/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package fr.atesab.sw.tp5;

import java.io.File;
import java.io.FileWriter;

import org.apache.commons.codec.Charsets;
import org.apache.jena.datatypes.xsd.XSDDatatype.XSDGenericType;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdfconnection.RDFConnectionFactory;
import org.apache.jena.vocabulary.RDF;
import org.apache.jena.vocabulary.RDFS;
import org.apache.jena.vocabulary.XSD;

import fr.atesab.sw.tp5.model.AgencyData;
import fr.atesab.sw.tp5.model.RouteData;
import fr.atesab.sw.tp5.model.StopData;

public class Start {

    /**
     * stop.txt file to read
     */
    public static final String AGENCY_FILE = "data/export-ter-gtfs-last/agency.txt";
    public static final String ROUTES_FILE = "data/export-ter-gtfs-last/routes.txt";
    public static final String STOP_FILE = "data/export-ter-gtfs-last/stops.txt";
    public static final String GEO_NAMESPACE = "http://www.w3.org/2003/01/geo/wgs84_pos#";
    public static final String EXT_NAMESPACE = "http://www.example.com/";
    public static final String DATASET_URL = "http://localhost:3030/dataset";
    public static final boolean SEND_TO_SERVER = false;

    public static void main(String[] args) {
        // create an empty Model

        var model = ModelFactory.createDefaultModel()
                // base ns
                .setNsPrefix("ex", EXT_NAMESPACE)
                // rdfs ns
                .setNsPrefix("rdfs", RDFS.getURI())
                // xsd ns
                .setNsPrefix("xsd", XSD.getURI())
                // geo ns
                .setNsPrefix("geo", GEO_NAMESPACE);

        var latProperty = model.createProperty(GEO_NAMESPACE + "lat");
        var longProperty = model.createProperty(GEO_NAMESPACE + "long");
        var spatialThing = model.createResource(GEO_NAMESPACE + "SpatialThing");
        var stopDescProperty = model.createProperty(EXT_NAMESPACE + "stopDesc");
        var stopUrlProperty = model.createProperty(EXT_NAMESPACE + "stopUrl");
        var locationTypeProperty = model.createProperty(EXT_NAMESPACE + "locationType");
        var parentStationProperty = model.createProperty(EXT_NAMESPACE + "parentStation");
        var locationTypeResources = LocationType.buildMap(EXT_NAMESPACE, model);

        /*
         * Read the stops.txt file
         */

        new CSVReader<>(STOP_FILE, StopData::new).readFile(sdata -> {
            // stopId
            var r = model.createResource(EXT_NAMESPACE + sdata.stopId)
                    // set type
                    .addProperty(RDF.type, spatialThing) // a geo:SpacialThing
                    // stopName
                    .addProperty(RDFS.label, sdata.stopName)
                    // stopLat
                    .addProperty(latProperty, sdata.stopLat, XSDGenericType.XSDdecimal)
                    // stopLon
                    .addProperty(longProperty, sdata.stopLon, XSDGenericType.XSDdecimal);

            // stopDesc
            if (!sdata.stopDesc.isEmpty())
                r.addProperty(stopDescProperty, sdata.stopDesc);

            // stopUrl
            if (!sdata.stopUrl.isEmpty())
                r.addProperty(stopUrlProperty, model.createResource(sdata.stopUrl));
            // locationType
            var locationType = locationTypeResources[Integer.parseInt(sdata.locationType)];
            r.addProperty(locationTypeProperty, locationType.resource());

            // parentStation
            switch (locationType.id()) {
            case 0: // Stop/platform (location_type=0): the parent_station field contains the ID of
                    // a station
            case 2:
            case 3: // Entrance/exit (location_type=2) or generic node (location_type=3): the
                // parent_station field contains the ID of a station (location_type=1)
                // a station
            case 4: // Boarding Area (location_type=4): the parent_station field contains ID of a
                // platform
                if (!sdata.parentStation.isEmpty()) {
                    r.addProperty(parentStationProperty, model.createResource(EXT_NAMESPACE + sdata.parentStation));
                }
                break;
            case 1: // Station (location_type=1): this field must be empty
            default:
                break;
            }

        });

        /*
         * Read the routes.txt file
         */

        new CSVReader<>(ROUTES_FILE, RouteData::new).readFile(rdata -> {
            // routeId
            // agencyId
            // routeShortName
            // routeLongName
            // routeDesc
            // routeType
            // routeUrl
            // routeColor
            // routeTextColor
            // TODO: add triples

        });
        /*
         * Read the agency.txt file
         */

        new CSVReader<>(AGENCY_FILE, AgencyData::new).readFile(adata -> {
            // agencyId
            // agencyName
            // agencyUrl
            // agencyTimezone
            // agencyLang
            // TODO: add triples
        });
        // TODO: continue for each files
        if (SEND_TO_SERVER) {
            try (var conneg = RDFConnectionFactory.connect(DATASET_URL)) {
                conneg.load(model); // add the content of model to the triplestore
            }
        } else {
            if (args.length > 0) {
                // send to the file
                try (var w = new FileWriter(new File(args[0]), Charsets.UTF_8)) {
                    model.write(w, "TURTLE");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                // send to standard output
                model.write(System.out, "TURTLE");
            }
        }

    }
}
